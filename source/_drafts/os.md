title: 操作系统知识复习
toc: true
tags:
category: os
---

# 问题

- 逻辑地址

由`页号`和`页内偏移量`两部分组成

- 物理地址

块号和块内偏移量

- 逻辑地址转换成物理地址

逻辑地址  ->  页号和页内偏移  -> 页表中找出页号对应的块号 -> 块号 x 页大小 + 偏移量

- 页大小

太小 -> 页表过长
太大 -> 内部碎片

- 内碎片?

>因为所有的内存分配必须起始于可被 4、8 或 16 整除（视处理器体系结构而定）的地址或者因为MMU的分页机制的限制，决定内存分配算法仅能把预定大小的内存块分配给客户。假设当某个客户请求一个 43 字节的内存块时，因为没有适合大小的内存，所以它可能会获得 44字节、48字节等稍大一点的字节，因此由所需大小四舍五入而产生的多余空间就叫内部碎片。

- 外碎片?

> 频繁的分配与回收物理页面会导致大量的、连续且小的页面块夹杂在已分配的页面中间，就会产生外部碎片。假设有一块一共有100个单位的连续空闲内存空间，范围是0~99。如果你从中申请一块内存，如10个单位，那么申请出来的内存块就为0~9区间。这时候你继续申请一块内存，比如说5个单位大，第二块得到的内存块就应该为10~14区间。如果你把第一块内存块释放，然后再申请一块大于10个单位的内存块，比如说20个单位。因为刚被释放的内存块不能满足新的请求，所以只能从15开始分配出20个单位的内存块。现在整个内存空间的状态是0~9空闲，10~14被占用，15~24被占用，25~99空闲。其中0~9就是一个内存碎片了。如果10~14一直被占用，而以后申请的空间都大于10个单位，那么0~9就永远用不上了，变成外部碎片。

- 段式内存管理?
- 页式内存管理?

> 系统为每一个进程建立一个页表
> 页表给出逻辑页号和具体内存块号相应的关系

- 重定位问题?

- 快表?

> 介于内存与寄存器之间的存储机制, 存放当前执行进程中最常用的页号与所对应的页框号, 从而提高查找速度



